MODULE SCANINPMOD
  USE GLOBAL
  USE INFOMOD,ONLY:READSTR
  
  IMPLICIT NONE
  
CONTAINS

  SUBROUTINE SCANEFDC(NCSER1,NCSER2,NCSER3,NCSER4)
  
    INTEGER :: K,NT,I,M,M1,NN
    INTEGER :: NDUM,ISTOCNT,ISO,ITIDASM,NPFOR,NCSER1,NCSER2,NCSER3
    INTEGER :: NCSER4,ITMPPMX,ITSSS,NS,IS,IITMP,IJTMP,NPMXZ,NPMXPTS
    INTEGER :: ISBEDTEMI  ! *** DEPRECATED VARIABLE
    REAL    :: DIFTOXNT,DIFTOXSNT
    REAL    :: PDIFTOXNT,DPDIFTOXNT,R,TC1,TAV1
    REAL    :: R1TMP,R2TMP,R3TMP,R4TMP,R5TMP,PMIXSF
    CHARACTER(*) :: STR*200,CFILE*15

    CFILE = 'EFDC.INP'
    WRITE(*,'(A)')'SCANNING INPUT FILE: EFDC.INP'
    OPEN(1,FILE='efdc.inp',STATUS='OLD')

    CALL SEEK('C1')
    READ(1,'(A100)') RUNTITLE

    CALL SEEK('C1A')
    !READ(1,*,ERR=10) IGRIDH,KMINV,IGRIDV,IS2TIM,ISHOUSATONIC
    READ(1,*,ERR=10) IS2TIM,IGRIDH,IGRIDV,KMINV,SGZHPDELTA
                                                                  
    CALL SEEK('C2')
    READ(1,*,ERR=10) ISRESTI,ISRESTO,ISRESTR,ISGREGOR,ISLOG,ISDIVEX,ISNEGH,ISMMC,ISBAL,ICONTINUE,ISHOW
  
    CALL SEEK('C4')
    READ(1,*,ERR=10) ISLTMT,ISSSMMT,ISLTMTS,ISIA,RPIA,RSQMIA,ITRMIA,ISAVEC
    IF( ISLTMT > 0 )THEN
      STOP'ISLTMT LONG TERM SIMULATION DISABLED!'
    ENDIF

    CALL SEEK('C5')
    READ(1,*,ERR=10) ISCDMA,ISHDMF,ISDISP,ISWASP,ISDRY,ISQQ,ISRLID,ISVEG,ISVEGL,ISITB,IHMDSUB,IINTPG
    IF( ISCDMA == 10 )THEN
      STOP'EFDC 1D CHANNEL MODE IS DISABLED IN THIS VERSION OF EFDC'
    ENDIF
    IF( ISCDMA > 2 )THEN
      STOP'EXPERIMENTAL MOMENTUM OPTIONs ARE ARE DISABLED IN THIS VERSION OF EFDC'
    ENDIF

    CALL SEEK('C6')
    DO NN=0,8
      READ(1,*,ERR=10) ISTRAN(NN),ISTOPT(NN),ISCDCA(NN),ISADAC(NN),ISFCT(NN),ISPLIT(NN),ISADAH(NN),ISADAV(NN),ISCI(NN),ISCO(NN)
    ENDDO

    CALL SEEK('C7')
    READ(1,*,ERR=10) NTC,NTSPTC,NLTC,NTTC,NTCPP,NTSTBC,NTCNB,NTCVB,NTSMMT,NFLTMT,NDRYSTP
    NDDAM=NTC

    CALL SEEK('C9')
    READ(1,*,ERR=10,END=30)IC,JC,LC,LVC,ISCLO,NDM,LDM,ISMASK,ISCONNECT,NSHMAX,NSBMAX,WSMH,WSMB
    IF( IC >= 3 )THEN
      ICM=IC+1
    ELSE
      STOP'IC MUST BE AT LEAST 3'
    ENDIF
    IF( JC >= 3 )THEN
      JCM=JC+1
    ELSE
      STOP'IJ MUST BE AT LEAST 3'
    ENDIF
    IF( LC >= 3 )THEN
      LCM=LC+1
    ELSE
      STOP'LC MUST BE AT LEAST 3'
    ENDIF

    CALL SEEK('C9A')
    READ(1,*,IOSTAT=ISO)KC,KSIG,ISETGVC,SELVREF,BELVREF,ISGVCCK
    KC=ABS(KC)
    IF( KC >= 1 )THEN
      KCM=KC+1
    ELSE
      STOP'KC MUST BE AT LEAST 1'
    ENDIF

    CALL SEEK('C12A')
    READ(1,*,IOSTAT=ISO)ISTOPT(0),ISSQL,ISAVBMX,ISFAVB,ISINWV,ISLLIM,IFPROX,ISVTURB,BC_EDGEFACTOR
    
    CALL SEEK('C14')
    READ(1,*,ERR=10,END=30)MTIDE,NWSER,NASER,ISGWIT,ISCHAN,ISWAVE,ITIDASM,ISPERC,ISBODYF,ISPNHYDS
    MTM=MAX(1,MTIDE)+1
    NWSERM=MAX(1,NWSER)
    NASERM=MAX(1,NASER)
    NGWSERM=1
    NDASER=1
    NDGWSER=1
    
    CALL SEEK('C16')
    READ(1,*,ERR=10,END=30)NPBS,NPBW,NPBE,NPBN,NPFOR,NPFORT,NPSER,PDGINIT
    NPBSM=MAX(1,NPBS)
    NPBWM=MAX(1,NPBW)
    NPBEM=MAX(1,NPBE)
    NPBNM=MAX(1,NPBN)
    NPSERM=MAX(1,NPSER)
    NPFORM=MAX(1,NPFOR,NPSER)
    NDPSER=1

    CALL SEEK('C22')
    READ(1,*,ERR=10,END=30)NTOX,NSED,NSND,NCSER1,NCSER2,NCSER3,NCSER4,NTOXSER,NSEDSER,NSNDSER,ISSBAL

    ! *** REMOVE UNUSED SETTINGS TO ALLOW FOR SELECTIVE ALLOCATIONS
    NTXM=MAX(1,NTOX)
    NSCM=MAX(1,NSED)
    NSNM=MAX(1,NSND)
    IF ( ISTRAN(6) < 1)  NSED = 0   
    IF ( ISTRAN(7) < 1 ) NSND = 0
    IF ( NSED == 0 .AND. NSND == 0 ) ISTRAN(5) = 0
    IF ( ISTRAN(5) < 1 ) NTOX = 0
    IF( NTOX == 0 ) NTOXSER = 0
    IF( NSED == 0 ) NSEDSER = 0
    IF( NSND == 0 ) NSNDSER = 0

    NCSERM=MAX(1,NCSER1,NCSER2,NCSER3,NCSER4,NTOXSER,NSEDSER,NSNDSER)
    NDCSER=1

    ALLOCATE(TSSAL(NCSER1),TSTEM(NCSER2),TSDYE(NCSER3),TSSFL(NCSER4),TSTOX(NTOXSER,NTOX),TSSED(NSEDSER,NSED),TSSND(NSNDSER,NSND))
    NSTA(1) = NCSER1
    NSTA(2) = NCSER2
    NSTA(3) = NCSER3
    NSTA(4) = NCSER4
    NSTA(5) = NTOXSER
    NSTA(6) = NSEDSER
    NSTA(7) = NSNDSER

    CALL SEEK('C23')
    READ(1,*,ERR=10,END=30)NQSIJ,NQJPIJ,NQSER,NQCTL,NQCTLT,NHYDST,NQWR,NQWRSR,ISDIQ,NQCTLSER,NQCRULES
    NQSIJM=MAX(1,NQSIJ)
    NQJPM=MAX(1,NQJPIJ)
    NJPSM=NQJPM
    NQSERM=MAX(1,NQSER)
    NQCTLM=MAX(1,NQCTL)
    NQCTTM=MAX(1,NQCTLT)
    NQWRM=MAX(1,NQWR)
    NQWRSRM=MAX(1,NQWRSR)
    NDQSER=1   ! *** Flow              : Maximum number of  points in !a series
    NDQWRSR=1  ! *** Withdrawal/Return : Maximum number of  points in !a series

    ! *** SET KB AND CHECK FOR SEDZLJ USEAGE
    NSEDFLUME=0
    NWARNING = 0
    LSEDZLJ = .FALSE.
    IF( NSED > 0 .OR. NSND > 0 )THEN
      CALL SEEK('C36')
      READ(1,*,ERR=10,END=30)ISEDINT,ISEDBINT,ISEDWC,ISMUD,ISNDWC,ISEDVW,ISNDVW,KB,ISDTXBUG
      IF( KB >= 1 )THEN
        KBM=KB+1
      ELSE
        STOP 'KB MUST BE AT LEAST 1'
      ENDIF
      IF( ISTRAN(6) > 0 )THEN
        IF( ISEDWC == 98 )THEN
          LSEDZLJ = .TRUE.
          NSEDFLUME=1
        ELSEIF( ISEDWC == 99 )THEN
          LSEDZLJ = .TRUE.
          NSEDFLUME=2
        ENDIF
      ENDIF

      ! *** LOOK FOR LEGACY APPROACH TO SET SEDZLJ, I.E. IWRSP(1)=98
      IF(  .NOT. LSEDZLJ .AND. ISTRAN(6) > 0 )THEN
        ISDTXBUG=0
        !C40*  READ COHESIVE SEDIMENT PARAMETER SET 2 REPEAT DATA LINE NSED TIMES
        CALL SEEK('C40')
        READ(1,*,ERR=10,END=30)ISDTXBUG
        IF( ISDTXBUG == 98 )THEN
          LSEDZLJ = .TRUE.
          NSEDFLUME=1
        ENDIF
      ENDIF
    ELSE
      KBM=1
    ENDIF

    ITMPPMX=0
    IF( NTOX > 0 )THEN
      CALL SEEK('C44')
      ! *** NEED TO READ EVEN IF SEDZLJ IS BEING USED
      DO NT=1,NTOX
        READ(1,*,ERR=10)NDUM,ISTOCNT,DIFTOXNT,DIFTOXSNT,PDIFTOXNT,DPDIFTOXNT
        IF( PDIFTOXNT < 0. )ITMPPMX=1
      ENDDO

      CALL SEEK('C45A')
      READ(1,*,ERR=10)ISTDOCW,ISTPOCW,ISTDOCB,ISTPOCB,STDOCWC,STPOCWC,STDOCBC,STPOCBC
    ENDIF

    CALL SEEK('C46')
    READ(1,*,ERR=10,END=30)BSC,TEMO,HEQT,ISBEDTEMI,KBH,RKDYE,NCBS,NCBW,NCBE,NCBN
    NBBSM=MAX(1,NCBS)
    NBBWM=MAX(1,NCBW)
    NBBEM=MAX(1,NCBE)
    NBBNM=MAX(1,NCBN)

    CALL SEEK('C46A')
    READ(1,*,ERR=10,END=30)ISICE,NISER,TEMPICE,CDICE,ICETHMX,RICETHK0
    
    IF ( NASER > 0 ) THEN
      CALL SEEK('C46D')
      READ(1,*,IOSTAT=ISO) IASWRAD,REVC,RCHC,ISVHEAT,SWRATNF,SWRATNS,FSWRATF,DABEDT,TBEDIT,HTBED1,HTBED2
    ENDIF
    
    CALL SEEK('C66A')
    READ(1,*,ERR=10) NLCDA,TSCDA,(ISCDA(K),K=1,7)
    NLDAM=NLCDA

    CALL SEEK('C67')
    READ(1,*,ERR=10) ISPD,NPD,NPDRT,NWPD,ISLRPD,ILRPD1,ILRPD2,JLRPD1, JLRPD2, MLRPDRT,IPLRPD
    NPDM=MAX(1,NPD)

    CALL SEEK('C80')
    READ(1,*,ERR=10,END=30)IS3DO,ISR3DO,NP3DO,KPC,NWGG,I3DMIN,I3DMAX,J3DMIN,J3DMAX,I3DRW,SELVMAX,BELVMIN
    KPCM=MAX(1,KPC)

    CALL SEEK('C82')
    READ(1,*,ERR=10,END=30)ISLSHA,MLLSHA,NTCLSHA,ISLSTR,ISHTA
    MLM=MAX(1,MLLSHA)

    CALL SEEK('C84')
    READ(1,*,ERR=10,END=30)ISTMSR,MLTMSR,NBTMSR,NSTMSR,NWTMSR,NTSSTSP,TCTMSR
    MLTMSRM=MAX(1,MLTMSR)
    NTSSTSPM=MAX(1,NTSSTSP)
    MTSSTSPM=1
    IF( NTSSTSP > 0 )THEN
      CALL SEEK('C85')
      DO ITSSS=1,NTSSTSP
        READ(1,*,ERR=10,END=30)I,M
        MTSSTSPM=MAX(MTSSTSPM,M)
      ENDDO
    ENDIF

    CLOSE(1)

    IF( ISVEG >= 1 )THEN
      CFILE = 'VEGE.INP'
      OPEN(1,FILE='vege.inp',STATUS='UNKNOWN')
      DO NS=1,12
        READ(1,*)
      ENDDO
      READ(1,*,ERR=10,END=30)MVEGTYP,MVEGOW,NVEGSER,UVEGSCL
      NVEGTPM = MAX(NVEGTPM,MVEGTYP)
      NVEGSERM = MAX(NVEGSERM,NVEGSER)
      CLOSE(1)

      IF( NVEGSER >= 1 )THEN
        CFILE = 'VEGSER.INP'
        OPEN(1,FILE='vegser.inp',STATUS='UNKNOWN')
        DO IS=1,8
          READ(1,*)
        ENDDO
        DO NS=1,NVEGSER
          READ(1,*,ERR=10,END=30) M1,TC1,TAV1
          NDVEGSER=MAX(NDVEGSER,M1)
          DO M=1,M1
            READ(1,*)
          ENDDO
        ENDDO
        CLOSE(1)
      ENDIF

      ! *** DETERMINE IF MHK IS USED
      LMHK=.FALSE.
      CFILE = 'DXDY.INP'
      OPEN(1,FILE='dxdy.inp',STATUS='UNKNOWN')
      DO I=1,4
        READ(1,*)
      ENDDO
      TCOUNT=0
      DO I=1,LVC
        READ(1,*)IITMP,IITMP,R1TMP,R2TMP,R3TMP,R4TMP,R5TMP,IJTMP
        IF( IJTMP > 90 )THEN
          LMHK=.TRUE.
          TCOUNT=TCOUNT+1
        ENDIF
      ENDDO
      CLOSE(1)

      IF( LMHK )THEN
        CFILE = 'MHK.INP'
        OPEN(1,FILE='mhk.inp',STATUS='UNKNOWN')
        DO NS=1,29
          READ(1,*,ERR=10,END=30)
        ENDDO
        READ(1,*,ERR=10,END=30)MHKTYP
        CLOSE(1)
      ENDIF
    ENDIF

    ! *** BANK EROSION
    IF( ISBKERO >= 1 )THEN
      CFILE = 'BEMAP.INP'
      OPEN(1,FILE='bemap.inp',STATUS='UNKNOWN')
      DO IS=1,10
        READ(1,*,ERR=10,END=30)
      ENDDO
      READ(1,*,ERR=10,END=30)NBEPAIR,NBESER
      NBEPAIRM=NBEPAIR
      NBESERM=NBESER
      CLOSE(1)

      NDBESER=1
      IF( NBESER > 0 )THEN
        CFILE = 'BESER.INP'
        OPEN(1,FILE='beser.inp',STATUS='UNKNOWN')

        DO NS=1,NBESER
          100 READ(1,*,ERR=100,END=30)M,R,R,R,R
          NDBESER=MAX(NDBESER,M)
          DO I=1,M
            READ(1,*,ERR=10,END=30)R,R,R
          ENDDO
        ENDDO
        CLOSE(1)
      ENDIF
    ENDIF

    ! *** SEDIMENT MIXING
    NPMXPTSM=1
    NPMXZM=1
    IF( ISTRAN(5) > 0 .AND. ITMPPMX == 1 )THEN
      CFILE = 'PARTMIX.INP'
      OPEN(1,FILE='partmix.inp')
      ! **  SKIP OVER TITLE AND AND HEADER LINES
      DO IS=1,7
        READ(1,*)
      ENDDO
      READ(1,*)NPMXZ,NPMXPTS,PMIXSF
      NPMXPTSM=NPMXPTS
      NPMXZM=NPMXZ
      CLOSE(1)
    ENDIF

    IF( ISCONNECT >= 2 )THEN
      WRITE(*,'(A)')'READING MAPPGEW.INP'
      OPEN(1,FILE='mappgew.inp',STATUS='UNKNOWN')
                                                                                    
      ! *** SKIP OVER TITLE AND AND HEADER LINES                                                                              
      STR=READSTR(1)    
      READ(1,*,IOSTAT=ISO) NPEWBP
      CLOSE(1)
    ENDIF

    IF( ISCONNECT == 1 .OR. ISCONNECT == 3 )THEN
      CFILE='MAPPGNS.INP'
      OPEN(1,FILE='mappgns.inp',STATUS='UNKNOWN')
                                                                                    
      ! *** SKIP OVER TITLE AND AND HEADER LINES                                                                              
      STR=READSTR(1)    
      READ(1,*,IOSTAT=ISO) NPNSBP
      CLOSE(1)
    ENDIF

    MDCHH=0
    IF( ISCHAN>0 )THEN
      CFILE='MODCHAN.INP'
      OPEN(1,FILE='modchan.inp',STATUS='UNKNOWN')

      ! *** SKIP OVER TITLE AND AND HEADER LINES                                                                              
      DO IS=1,8
        READ(1,*)
      ENDDO

      READ(1,*) MDCHH,MDCHHD,MDCHHD2
      CLOSE(1)
    ENDIF

    IF( NWSER > 1 )THEN
      OPEN(1,FILE='wndmap.inp',STATUS='UNKNOWN')
      STR=READSTR(1)    
      READ(1,*,IOSTAT=ISO) NWNDMAP
      IF( ISO /= 0) STOP ' *** WNDMAP.INP: READING ERROR!'
      CLOSE(1)
      ALLOCATE(TWNDMAPBEG(NWNDMAP),TWNDMAPEND(NWNDMAP))
      ALLOCATE(WNDWHT(NWSER,LCM,NWNDMAP))
    ENDIF
  
    IF( NASER > 1 )THEN
      OPEN(1,FILE='atmmap.inp',STATUS='UNKNOWN')
      STR=READSTR(1)    
      READ(1,*,IOSTAT=ISO) NATMMAP
      IF( ISO /= 0) STOP ' *** ATMMAP.INP: READING ERROR!'
      CLOSE(1)
      ALLOCATE(TATMMAPBEG(NATMMAP),TATMMAPEND(NATMMAP))
      ALLOCATE(ATMWHT(NASER,LCM,NATMMAP))
    ENDIF
    
    IF( ISICE == 1 .AND. NISER > 1 )THEN
      OPEN(1,FILE='icemap.inp',STATUS='UNKNOWN')
      STR=READSTR(1)    
      READ(1,*,IOSTAT=ISO) NICEMAP
      IF( ISO /= 0) STOP ' *** ICEMAP.INP: READING ERROR!'
      CLOSE(1)
      ALLOCATE(TICEMAPBEG(NICEMAP),TICEMAPEND(NICEMAP))
      ALLOCATE(RICEWHT(NICEMAP,LCM,NISER))
    ENDIF
    
    RETURN

    ! *** ERROR MESSAGES
    10 WRITE(*,'(A)') '  READ ERROR IN INPUT FILE: '//TRIM(CFILE)
    WRITE(8,'(A)') '  READ ERROR IN INPUT FILE: '//TRIM(CFILE)
    STOP

    30 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: '//TRIM(CFILE)
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: '//TRIM(CFILE)
    STOP

  END SUBROUTINE
  
  SUBROUTINE SCANMODC
    INTEGER :: M,I
    REAL    :: R

    WRITE(*,'(A)')'SCANNING INPUT FILE: MODCHAN.INP'
    OPEN(1,FILE='modchan.inp',STATUS='OLD')
    10 READ(1,*,ERR=10,END=40)M,I,I
    NCHANM=MAX(1,M)
    READ(1,*,ERR=20,END=40)I,I,R
    CLOSE(1)
    RETURN

    20 WRITE(*,'(A)') '  READ ERROR IN INPUT FILE: MODCHAN.INP'
    WRITE(8,'(A)') '  READ ERROR IN INPUT FILE: MODCHAN.INP'
    STOP
    
    40  WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: MODCHAN.INP'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: MODCHAN.INP'
    STOP
     
  END SUBROUTINE
  
  SUBROUTINE SCANGWSR
    INTEGER :: I,J,M,NS
    REAL    :: R,T,F

    WRITE(*,'(A)')'SCANNING INPUT FILE: GWSER.INP'
    OPEN(1,FILE='gwser.inp',STATUS='OLD')
    10 READ(1,*,ERR=10,END=40)NGWSER
    NGWSERM=MAX(1,NGWSER)
    DO NS=1,NGWSER
      READ(1,*,ERR=20,END=40)M,R,R,R,R,I
      NDGWSER=MAX(NDGWSER,M)
      DO I=1,M
        READ(1,*,ERR=20,END=40)T,F,(R,J=1,4+NSED+NSND+NTOX)
      ENDDO
    ENDDO
    CLOSE(1)
    RETURN

    20 WRITE(*,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: GWSER.INP IN SERIES:',NS,', POINT:',I 
    WRITE(8,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: GWSER.INP IN SERIES:',NS,', POINT:',I
    STOP

    40 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: GWSER.INP'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: GWSER.INP'
    STOP
  END SUBROUTINE
  
  SUBROUTINE SCANASER
    USE INFOMOD,ONLY:SKIPCOM 
    INTEGER :: M,I,NS
    REAL    :: R
    CHARACTER*120 LIN,STR*200

    WRITE(*,'(A)')'SCANNING INPUT FILE: ASER.INP'
    OPEN(1,FILE='aser.inp',STATUS='OLD')
    ALLOCATE(TSATM(NASER))
    
    CALL SKIPCOM(1,'*')    
    READ(1,'(A)') STR
    STR=READSTR(1)
    
    DO NS=1,NASER
      READ(1,*,END=40)M,R,R,I,R,R,R,R
      !READ(1,*,ERR=20,END=40)I,R,R,R,R,R,R,R,R,R
      NDASER=MAX(NDASER,M)     
      ALLOCATE(TSATM(NS).TIM(M),TSATM(NS).VAL(M,7))
      TSATM(NS).NREC= M
      TSATM(NS).TIM = 0
      TSATM(NS).VAL = 0
      
      DO I=1,M
        READ(1,*,ERR=20,END=40)R,R,R,R,R,R,R,R
      ENDDO
    ENDDO
    CLOSE(1)

    IF( ISTRAN(8) > 0 )THEN
      IF( IWQSUN == 1 )THEN
        WRITE(*,'(A)')'SCANNING INPUT FILE: SUNDAY.INP'
        OPEN(1,FILE='sunday.inp',STATUS='UNKNOWN')
        M=0
        DO I = 1,7
          READ(1,'(A120)',ERR=30,END=40)LIN
        END DO
        READ(1,*,ERR=30,END=40)M,R,R,R,R
        CLOSE(1)
        NDASER=MAX(NDASER,M)
      ENDIF
    ENDIF

    RETURN

    20 WRITE(*,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: ASER.INP IN SERIES:',NS,', POINT:',I
    WRITE(8,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: ASER.INP IN SERIES:',NS,', POINT:',I
    STOP
    30 WRITE(*,'(A)') '  READ ERROR IN INPUT FILE'
    WRITE(8,'(A)') '  READ ERROR IN INPUT FILE'
    STOP

    40 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE'
    STOP
       
  END SUBROUTINE
  
  SUBROUTINE SCANSSER(NCSER1)
    INTEGER :: NCSER1,NS,I,J,M,K
    REAL   :: R
  
    WRITE(*,'(A)')'SCANNING INPUT FILE: SSER.INP'
    OPEN(1,FILE='sser.inp',STATUS='OLD')
    DO NS=1,NCSER1
       10   READ(1,*,ERR=10,END=40)I,M,R,R,R,R
      NDCSER=MAX(NDCSER,M)
  
      ALLOCATE(TSSAL(NS).VAL(M,KCM),TSSAL(NS).TIM(M))
      TSSAL(NS).NREC=M
      TSSAL(NS).VAL(:,:)=0
      TSSAL(NS).TIM(:)=0
  
      IF( I == 1 )THEN
        READ(1,*,ERR=20,END=40)(R,K=1,KC)
        DO J=1,M
          READ(1,*,ERR=20,END=40)R,R
        ENDDO
      ELSE
        DO J=1,M
          READ(1,*,ERR=20,END=40)R,(R,K=1,KC)
        ENDDO
      ENDIF
    ENDDO
    CLOSE(1)
    RETURN

    20 WRITE(*,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: SSER.INP IN SERIES:',NS,', POINT:',J
    WRITE(8,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: SSER.INP IN SERIES:',NS,', POINT:',J
    STOP

    40 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: SSER.INP'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: SSER.INP'
    STOP
  END SUBROUTINE
  
  SUBROUTINE SCANTSER(NCSER2)
    INTEGER   :: NCSER2,NS,I,J,K,M,NN
    REAL      :: R
    CHARACTER(200) :: STR
  
    WRITE(*,'(A)')'SCANNING INPUT FILE: TSER.INP'

    OPEN(1,FILE='tser.inp',STATUS='OLD')
  
    STR=READSTR(1)
  
    DO NS=1,NCSER2
      READ(1,*,ERR=991) I,M,R,R,R,R
      NDCSER=MAX(NDCSER,M)
  
      ALLOCATE(TSTEM(NS).VAL(M,KCM),TSTEM(NS).TIM(M))    
      TSTEM(NS).NREC=M
      TSTEM(NS).VAL(:,:)=0
      TSTEM(NS).TIM(:)=0

      IF( I == 1 )THEN
        READ(1,*,ERR=991) (R,K=1,KC)
        DO J=1,M
          READ(1,*,ERR=991) R,R
        ENDDO
      ELSE
        DO J=1,M
          READ(1,*,ERR=991) R,(R,K=1,KC)
        ENDDO
      ENDIF
    ENDDO
    CLOSE(1)

    IF( ISICE == 1 .AND. NISER >= 1 )THEN
      WRITE(*,'(A)')'SCANNING INPUT FILE: ISER.INP'
      ALLOCATE(TSICE(NISER))
      
      OPEN(1,FILE='iser.inp')
      STR=READSTR(1)
      DO NS=1,NISER
        READ(1,*,ERR=992) M,R,R,R,R         
        ALLOCATE(TSICE(NS).VAL(M,2),TSICE(NS).TIM(M))  ! ** VAL(M,1): ICE THICKNESS; VAL(M,2): ICE COVER        
        TSICE(NS).NREC= M
        TSICE(NS).VAL = 0
        TSICE(NS).TIM = 0                
        DO J=1,M
          READ(1,*,ERR=992)
        ENDDO
      ENDDO
      CLOSE(1)

    ELSEIF( ISICE == 2 )THEN
      WRITE(*,'(A)')'SCANNING INPUT FILE: ISTAT.INP'
      OPEN(1,FILE='istat.inp')  
      STR=READSTR(1)
      READ(1,*,ERR=993) M,R,R   !MISER(NN),TCISER(NN),TAISER(NN)
      NN=1
      ALLOCATE(TSICE(NN))
      ALLOCATE(TSICE(NN).VAL(M,2),TSICE(NN).TIM(M))  ! ** VAL(M,1): ICE THICKNESS; VAL(M,2): ICE COVER        
      TSICE(NN).NREC= M
      TSICE(NN).VAL = 0
      TSICE(NN).TIM = 0     
      CLOSE(1)
    ENDIF
  
    RETURN
    991 STOP '  TSER.INP: READING ERROR'
    992 STOP '  ISER.INP: READING ERROR' 
    993 STOP '  ISTAT.INP: READING ERROR'     
  END SUBROUTINE
  
  SUBROUTINE SCANDSER(NCSER3)
    INTEGER :: NCSER3,NS,I,K,M
    REAL   :: R
  
    WRITE(*,'(A)')'SCANNING INPUT FILE: DSER.INP'
    OPEN(1,FILE='dser.inp',STATUS='OLD')
    DO NS=1,NCSER3
       10   READ(1,*,ERR=10,END=40)I,M,R,R,R,R
      NDCSER=MAX(NDCSER,M)
  
      ALLOCATE(TSDYE(NS).VAL(M,KCM),TSDYE(NS).TIM(M))    
      TSDYE(NS).NREC=M
      TSDYE(NS).VAL(:,:)=0
      TSDYE(NS).TIM(:)=0

      IF( I == 1 )THEN
        READ(1,*,ERR=20,END=40)(R,K=1,KC)
        DO I=1,M
          READ(1,*,ERR=20,END=40)R,R
        ENDDO
      ELSE
        DO I=1,M
          READ(1,*,ERR=20,END=40)R,(R,K=1,KC)
        ENDDO
      ENDIF
    ENDDO
    CLOSE(1)
    RETURN

    20 WRITE(*,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: DSER.INP IN SERIES:',NS,', POINT:',I
    WRITE(8,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: DSER.INP IN SERIES:',NS,', POINT:',I
    STOP

    40 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: DSER.INP'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: DSER.INP'
    STOP
  END SUBROUTINE
   
  SUBROUTINE SCANSFSR(NCSER4)
    INTEGER :: NCSER4,NS,I,J,K,M
    REAL   :: R
  
    WRITE(*,'(A)')'SCANNING INPUT FILE: SFSER.INP'
    OPEN(1,FILE='sfser.inp',STATUS='OLD')
    DO NS=1,NCSER4
       10 READ(1,*,ERR=10,END=40)I,M,R,R,R,R
      NDCSER=MAX(NDCSER,M)
  
      ALLOCATE(TSSFL(NS).VAL(M,KCM),TSSFL(NS).TIM(M))    
      TSSFL(NS).NREC=M
      TSSFL(NS).VAL(:,:)=0
      TSSFL(NS).TIM(:)=0
      
      IF( I == 1 )THEN
        READ(1,*,ERR=20,END=40)(R,K=1,KC)
        DO J=1,M
          READ(1,*,ERR=20,END=40)R,R
        ENDDO
      ELSE
        DO J=1,M
          READ(1,*,ERR=20,END=40)R,(R,K=1,KC)
        ENDDO
      ENDIF
    ENDDO
    CLOSE(1)
    RETURN

    20 WRITE(*,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: SFSER.INP IN SERIES:',NS,', POINT:',J
    WRITE(8,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: SFSER.INP IN SERIES:',NS,', POINT:',J
    STOP

    40 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: SFSER.INP'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: SFSER.INP'
    STOP
  END SUBROUTINE
  
  SUBROUTINE SCANQSER
    INTEGER :: NS,I,J,M,K
    REAL    :: R,T,Q

    WRITE(*,'(A)')'SCANNING INPUT FILE: QSER.INP'
    OPEN(1,FILE='qser.inp',STATUS='OLD')

    ALLOCATE(QSER(NQSER))  

    DO NS=1,NQSER
       10   READ(1,*,ERR=10,END=40)I,M,R,R,R,R,J
      ALLOCATE(QSER(NS).VAL(M,KCM),QSER(NS).TIM(M))  
      QSER(NS).NREC = M
      QSER(NS).VAL(:,:) = 0.0
      QSER(NS).TIM(:) = 0.0
      
      !NDQSER=MAX(NDQSER,M)
      IF( I == 1 )THEN
        READ(1,*,ERR=20,END=40)(R,K=1,KC)
        DO J=1,M
          READ(1,*,ERR=20,END=40)T,Q
        ENDDO
      ELSE
        DO J=1,M
          READ(1,*,ERR=20,END=40)T,(Q,K=1,KC)
        ENDDO
      ENDIF
    ENDDO
    CLOSE(1)
    RETURN

    20 WRITE(*,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: QSER.INP IN SERIES:',NS,', POINT:',J 
    WRITE(8,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: QSER.INP IN SERIES:',NS,', POINT:',J
    STOP

    40 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: QSER.INP'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: QSER.INP'
    STOP
  END SUBROUTINE

  SUBROUTINE SCANQWSER
    INTEGER :: NTMP,I,J,M,NV,NS
    REAL(RKD)   :: R,T,Q

    NTMP=4+NSED+NSND+NTOX
    ! *** Handle Water Quality variables, if needed
    IF( ISTRAN(8) > 0 )THEN
      WRITE(*,'(A)')'SCANNING INPUT FILE: WQ3DWC.INP'
      OPEN(1,FILE='wq3dwc.inp',STATUS='OLD')

      CALL SEEK('C02')
      READ(1,*) ISWQLVL,NWQV,NWQZ,NWQPS,NWQTD,NWQTS,NTSWQV,NSMG,NSMZ,NTSSMV,NSMTS,WQKINUPT
      CLOSE(1)

      NTMP=NTMP+NWQV
    ENDIF

    WRITE(*,'(A)')'SCANNING INPUT FILE: QWRS.INP'
    OPEN(1,FILE='qwrs.inp',STATUS='OLD')

    DO NS=1,NQWRSR
       10 READ(1,*,ERR=10,END=40)I,M,R,R,R,R
      NDQWRSR=MAX(NDQWRSR,M)
      IF( I == 0 )THEN
        ! *** Flow Only
        DO J=1,M
          READ(1,*,ERR=20,END=40)T,Q
        ENDDO
      ELSE
        ! *** Flow with Rise/Fall
        DO J=1,M
          READ(1,*,ERR=20,END=40)T,Q,(R,NV=1,NTMP)
        ENDDO
      ENDIF
    ENDDO
    CLOSE(1)
    RETURN

    20 WRITE(*,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: QWRS.INP IN SERIES:',NS,', POINT:',J 
    WRITE(8,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: QWRS.INP IN SERIES:',NS,', POINT:',J

    40 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: QWRS.INP'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: QWRS.INP'
    STOP
  END SUBROUTINE

  SUBROUTINE SCANPSER
    INTEGER :: NS,M,I,I1
    REAL   :: R,T,E
  
    WRITE(*,'(A)')'SCANNING INPUT FILE: PSER.INP'
    OPEN(1,FILE='pser.inp',STATUS='OLD')
    DO NS=1,NPSER
       10   READ(1,*,ERR=10,END=40)I1,M,R,R,R,R
      NDPSER=MAX(NDPSER,M)
      IF( I1 == 1)READ(1,*)R,R,R
      DO I=1,M
        IF( I1 == 0 )THEN
          READ(1,*,ERR=20,END=40)T,E
        ELSEIF( I1 == 1 )THEN
          READ(1,*,ERR=20,END=40)T,E,R
        ENDIF
      ENDDO
    ENDDO
    CLOSE(1)
    RETURN

    20 WRITE(*,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: PSER.INP IN SERIES:',NS,', POINT:',I 
    WRITE(8,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: PSER.INP IN SERIES:',NS,', POINT:',I
    STOP

    40 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: PSER.INP'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: PSER.INP'
    STOP
  END SUBROUTINE

  SUBROUTINE SCANWSER
    INTEGER :: I,M,NS
    REAL    :: R
  
    WRITE(*,'(A)')'SCANNING INPUT FILE: WSER.INP'
    !ALLOCATE(WNDEF(NWSER),TSWND(NWSER))
    ALLOCATE(TSWND(NWSER))
    
    OPEN(1,FILE='wser.inp',STATUS='OLD')
    DO NS=1,NWSER
       10 READ(1,*,ERR=10,END=40)M,R,R,R,I
      
      ALLOCATE(TSWND(NS).TIM(M),TSWND(NS).VAL(M,2))
      TSWND(NS).NREC= M
      TSWND(NS).VAL = 0
      TSWND(NS).TIM = 0  
        
      DO I=1,M
        READ(1,*,ERR=20,END=40)R,R,R
      ENDDO
    ENDDO
    CLOSE(1)
    RETURN
  
    20 WRITE(*,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: WSER.INP IN SERIES:',NS,', POINT:',I 
    WRITE(8,'(A,I5,A,I10)') '  READ ERROR IN INPUT FILE: WSER.INP IN SERIES:',NS,', POINT:',I
    STOP

    40 WRITE(*,'(A)') '  UNEXPECTED END OF INPUT FILE: WSER.INP'
    WRITE(8,'(A)') '  UNEXPECTED END OF INPUT FILE: WSER.INP'
    STOP
  END SUBROUTINE

  SUBROUTINE SCANQCTL
    CHARACTER*80 :: SKIP
    CHARACTER*10 :: INFILE

    INTEGER :: M,M1,M2,MP,IS,NS,ISO,ISTYP
    REAL   :: HUA,HUM,HDA,HDM,R,A,A1

    WRITE(*,'(A)')'SCANNING INPUT FILE: QCTL.INP'
    INFILE='QCTL.INP'

    OPEN(1,FILE='qctl.inp',STATUS='UNKNOWN')

    ! *** FIND THE MAXIMUM NUMBER OF TABLE DATA POINTS
    NDQCLT=0
    DO IS=1,14
      READ(1,'(A)')SKIP
    ENDDO

    DO NS=1,NQCTLT
      READ(1,*,IOSTAT=ISO)ISTYP,MP,HUA,HUM,HDA,HDM,R,A,A1
      NDQCLT=MAX(NDQCLT,MP)
      IF( ISO > 0 )GOTO 20

      IF( ISTYP == 0 )THEN
        DO M=1,MP
          READ(1,'(A)')SKIP
        ENDDO
      ELSEIF( ISTYP == 1 )THEN
        READ(1,'(A)')SKIP
        DO M=1,MP
          READ(1,'(A)')SKIP
        ENDDO
      ELSEIF( ISTYP == 2 )THEN
        DO M1=1,MP
          DO M2=1,MP
            READ(1,'(A)')SKIP
          ENDDO
        ENDDO
      ELSEIF( ISTYP == 3 )THEN
        READ(1,'(A)')SKIP
        DO M1=1,MP
          DO M2=1,MP
            READ(1,'(A)')SKIP
          ENDDO
        ENDDO
      ENDIF
    ENDDO

    CLOSE(1)
    NDQCLT2=NDQCLT

    RETURN

    20 WRITE(*,'(A)') ' READ ERROR IN FILE: '//TRIM(INFILE)
    WRITE(8,'(A)') ' READ ERROR IN FILE: '//TRIM(INFILE)
    STOP

  END SUBROUTINE 

  SUBROUTINE SCANWQ
    USE INFOMOD,ONLY:SKIPCOM 
    CHARACTER*10  INFILE
    CHARACTER*2   SNUM
    CHARACTER*120 LINE
    CHARACTER*11  FNWQSR(40)
    LOGICAL*4     BFLAG
    INTEGER :: I,J,K,ITMP,NW,IWQDT,IWQKIN,M,TWQTSB,NS,ISTYP
    REAL   :: XPSQ,WQDIUDT,TWQTSE,TM,TA,RMULADJ,ADDADJ,T1,T2,TSMTSB,TSMTSE,SMTSDT
    CHARACTER(100) :: ERRSTR

    WRITE(*,'(A)')'SCANNING INPUT FILE: WQ3DWC.INP'
    INFILE='WQ3DWC.INP'

    OPEN(1,FILE='wq3dwc.inp',STATUS='UNKNOWN')

    CALL SEEK('C02')
    READ(1,*) ISWQLVL,NWQV,NWQZ,NWQPS,NWQTD,NWQTS,NTSWQV,NSMG,NSMZ,NTSSMV,NSMTS,WQKINUPT
    NWQZM=MAX(1,NWQZ)
    NWQPSM=MAX(1,NWQPS)
    NWQTDM=MAX(1,NWQTD)
    NWQVM=MAX(21,NWQV)	
    NWQTSM=MAX(1,NWQTS)
    NSMGM=MAX(1,NSMG)
    NSMZM=MAX(1,NSMZ)
    NTSSMVM=MAX(1,NTSSMV)
    NSMTSM=MAX(1,NSMTS)

    CALL SEEK('C03')
    READ(1,*) IWQDT,IWQM,IWQBEN,IWQSI,IWQFCB,IWQSRP,IWQSTOX, ITMP, IWQVLIM

    CALL SEEK('C04')
    READ(1,*) IWQZ,IWQNC,IWQRST,NDMWQ,LDMWQ,NDDOAVG,NDLTAVG,IDNOTRVA
    ! *** 2014-03  DEFAULT TO NWQVM+1 BECAUSE SOME WRITES ASSUME IDNOTRVA>0
    NWQVM = NWQVM+1
  
    CALL SEEK('C05')
    READ(1,*) IWQICI,IWQAGR,IWQSTL,IWQSUN,IWQPSL,IWQNPL, ISDIURDO, WQDIUDT, IWQKIN

    CALL SEEK('C06')
    READ(1,*) IWQTS,TWQTSB,TWQTSE,WQTSDT, ISWQAVG, ISWQMIN, ISWQMAX, ISCOMP
    IF( IWQTS > NWQTSM )THEN
      STOP ' IWQTS > NWQTSM'
    ENDIF

    !  *** C29
    CALL SEEK('C29')
    DO M=1,9
      READ(1,'(A120)')LINE
    ENDDO
    READ(1,*) (NWQCSR(NW),NW=1,NWQV)
    DO NW=1,NWQV
      NWQCSRM=MAX(NWQCSRM,NWQCSR(NW))
    ENDDO
    NCSERM=MAX(NCSERM,NWQCSRM)

    ! *** C48
    CALL SEEK('C48')
    READ(1,*) IWQPS,NPSTMSR
    IF( IWQPS > NWQPSM )THEN
      STOP ' IWQPS > NWQPSM'
    ENDIF

    IF( IWQPSL == 2 )THEN
      DO K=1,3
        READ(1,'(A120)')LINE
      ENDDO
      DO M=1,IWQPS
        READ(1,*) I,J,K,ITMP,XPSQ
        READ(1,'(A120)')LINE
        READ(1,'(A120)')LINE
        NCSERM=MAX(1,NCSERM,ITMP)
      ENDDO
    ELSE
      NWQPSRM=MAX(1,NPSTMSR)
    ENDIF
    CLOSE(1)

    ! *** SCAN THE TIME SERIES
    IF( NPSTMSR >= 1 .AND. IWQPSL /= 2 )THEN
      WRITE(*,'(A)')'SCANNING INPUT FILE: WQPSL.INP'
      OPEN(1,FILE='wqpsl.inp',STATUS='UNKNOWN')
      CALL SKIPCOM(1,'*')
      ERRSTR ='READING WPQSL.INP'
      DO NS=1,NPSTMSR
        READ(1,*,ERR=999,END=20) M,TM,TA,RMULADJ,ADDADJ
        NDWQPSR=MAX(NDWQPSR,M)
        DO J=1,M
          DO K=1,3
            READ(1,'(A120)')LINE
          ENDDO
        ENDDO
      ENDDO
      20 CLOSE(1)
    ENDIF

    ! *** SCAN THE OPEN BC TIME SERIES
    DO NW = 1,40
      WRITE(SNUM,'(I2.2)')NW
      FNWQSR(NW)='cwqsr'//SNUM//'.inp'
    ENDDO
  
    ! **  READ IN OPEN BOUNDARY OR VOLUMETRIC SOURCE WQ CONCENTRATION
    ! **  TIME SERIES FROM THE FILES CWQSRNN.INP
  
    NSTA(8) = 0
    WRITE(*,'(A)')'SCANNING INPUT FILE: CWQSRXX.INP'
    DO NW=1,NWQV
      INQUIRE(FILE=FNWQSR(NW),EXIST=BFLAG)
      IF( BFLAG )THEN
        OPEN(1,FILE=FNWQSR(NW),STATUS='UNKNOWN')
        ERRSTR = 'READING '//TRIM(FNWQSR(NW))
        CALL SKIPCOM(1,'*')
        DO NS=1,1000
          READ(1,*,ERR=999,END=40)ISTYP,M,T1,T2,RMULADJ,ADDADJ
          IF( ISTYP == 1 ) M = M+1   ! *** SKIP THE LAYER SPLITS
          DO J=1,M
            READ(1,'(A120)')LINE
          ENDDO
        ENDDO
        40 CLOSE(1)
        NSTA(8) = MAX(NSTA(8),NS-1)
      ENDIF
    ENDDO
    ALLOCATE(TSWQ(NSTA(8),NWQV))  

    DO NW=1,NWQV
      INQUIRE(FILE=FNWQSR(NW),EXIST=BFLAG)
      IF( BFLAG )THEN
        OPEN(1,FILE=FNWQSR(NW),STATUS='UNKNOWN')
        CALL SKIPCOM(1,'*')
        DO NS=1,NSTA(8)
          READ(1,*,END=45)ISTYP,M,T1,T2,RMULADJ,ADDADJ
          NDWQCSR=MAX(NDWQCSR,M)
          ALLOCATE(TSWQ(NS,NW).VAL(M,KCM),TSWQ(NS,NW).TIM(M))    
          TSWQ(NS,NW).NREC=M
          TSWQ(NS,NW).VAL=0
          TSWQ(NS,NW).TIM=0
          IF( ISTYP == 1 ) M = M+1   ! *** SKIP THE LAYER SPLITS
          DO J=1,M
            READ(1,'(A120)')LINE
          ENDDO
        ENDDO
        45 CLOSE(1)
      ENDIF
    ENDDO

    NDCSER=MAX(NDCSER,NDWQCSR)

    ! *** Sediment Diagenesis
    IF( IWQBEN == 1 )THEN
      WRITE(*,'(A)')'SCANNING INPUT FILE: WQ3DSD.INP'
      INFILE='WQ3DSD.INP'

      OPEN(1,FILE='wq3dsd.inp',STATUS='UNKNOWN')

      DO M=1,12
        READ(1,'(A120)')LINE
      ENDDO
      CALL SEEK('C02')
      READ(1,*) ISMZ,ISMICI,ISMRST,ISMHYST,ISMZB

      CALL SEEK('C03')
      READ(1,*) ISMTS,TSMTSB,TSMTSE,SMTSDT, ISSDBIN
      NSMTSM=MAX(ISMTS,NSMTS)
    
      CLOSE(1)
    ENDIF

    RETURN
 
    999 PRINT*,ERRSTR
    STOP
      
  END SUBROUTINE

  SUBROUTINE SCANSEDZLJ  
    !  REVISION DATE :  May 24, 2006
    !  Craig Jones and Scott James
    !***************************************************************
	  INTEGER :: IDUMMY,ERROR

	  WRITE(*,'(A)')'SCANNING INPUT FILE: BED.SDF'  
	  OPEN(1,FILE='bed.sdf',STATUS='OLD')  
	  READ(1,*,IOSTAT=ERROR) !SKIP THIS LINE
	  IF( ERROR == 1 )THEN
		  WRITE(*,'("READ ERROR IN SEDZLJ INPUT FILE")')  
		  WRITE(8,'("READ ERROR IN SEDZLJ INPUT FILE")')  
		  STOP
	  ENDIF
	  READ(1,*,IOSTAT=ERROR) IDUMMY,KB,NCALC_BL
	  IF( ERROR == 1 )THEN
		  WRITE(*,'("READ ERROR IN SEDZLJ INPUT FILE")')  
		  WRITE(8,'("READ ERROR IN SEDZLJ INPUT FILE")')  
		  STOP
	  ENDIF
	  READ(1,*,IOSTAT=ERROR) !SKIP THIS LINE
	  IF( ERROR == 1 )THEN
		  WRITE(*,'("READ ERROR IN SEDZLJ INPUT FILE")')  
		  WRITE(8,'("READ ERROR IN SEDZLJ INPUT FILE")')  
		  STOP
	  ENDIF
	  READ(1,*,IOSTAT=ERROR) ITBM,NSICM 
	  IF( ERROR == 1 )THEN
		  WRITE(*,'("READ ERROR IN SEDZLJ INPUT FILE")')  
		  WRITE(8,'("READ ERROR IN SEDZLJ INPUT FILE")')  
		  STOP
	  ENDIF
	  CLOSE(1)  

  END SUBROUTINE SCANSEDZLJ

  SUBROUTINE SCNTXSED
  INTEGER :: NCSERNC,NLOOP,IS,NS,ISTYP,NDATAPTS,NN,NT,M
  CHARACTER*80 SKIP
  CHARACTER*10 INFILE

  ! *** NOW FIND MAX FOR TOXICS AND SEDIMENTS
  DO NN=1,3
    NCSERNC=0
    IF( NN == 1 )THEN
      NC=5               ! MSVTOX(1)
      IF( NTOX > 0 .AND. NTOXSER > 0 )THEN
        WRITE(*,'(A)')'SCANNING INPUT FILE: TXSER.INP'
        INFILE='TXSER.INP'
        OPEN(1,FILE='txser.inp',STATUS='UNKNOWN')
        NLOOP=NTOX
        NCSERNC=NTOXSER  ! NCSER(NC)
      ENDIF
    ELSEIF( NN == 2 )THEN
      NC=NTOX+1          ! MSVSED(1)
      IF( NSED > 0 .AND. NSEDSER > 0 )THEN
        WRITE(*,'(A)')'SCANNING INPUT FILE: SDSER.INP'
        INFILE='SDSER.INP'
        OPEN(1,FILE='sdser.inp',STATUS='UNKNOWN')
        NLOOP=NSED
        NCSERNC=NSEDSER  ! NCSER(NC)
      ENDIF
    ELSEIF( NN == 3 )THEN
      NC=NTOX+NSED+1     ! MSVSND(1)
      IF( NSND > 0 .AND. NSNDSER > 0 )THEN
        WRITE(*,'(A)')'SCANNING INPUT FILE: SNSER.INP'
        INFILE='SNSER.INP'
        OPEN(1,FILE='snser.inp',STATUS='UNKNOWN')
        NLOOP=NSND
        NCSERNC=NSNDSER  ! NCSER(NC)
      ENDIF
    ENDIF

   IF( NCSERNC > 0 )THEN
      ! *** SKIP HEADER
      DO IS=1,15
        READ(1,'(A)') SKIP
      ENDDO
      ! *** LOOP OVER THE NUMBER OF SERIES
      DO NS=1,NSTA(NN+4)  !NCSERNC
        READ(1,*,ERR=20,END=40)ISTYP,NDATAPTS   !,X1,X2,X3,X4

        IF( NN == 1 .AND. NTOX > 0 .AND. NTOXSER > 0 )THEN
          DO NT=1,NTOX
            ALLOCATE(TSTOX(NS,NT).VAL(NDATAPTS,KCM),TSTOX(NS,NT).TIM(NDATAPTS))    
            TSTOX(NS,NT).NREC=NDATAPTS
            TSTOX(NS,NT).VAL=0
            TSTOX(NS,NT).TIM=0
          ENDDO
        
        ELSEIF( NN == 2 .AND. NSED > 0 .AND. NSEDSER > 0 )THEN
          DO NT=1,NSED
            ALLOCATE(TSSED(NS,NT).VAL(NDATAPTS,KCM),TSSED(NS,NT).TIM(NDATAPTS))    
            TSSED(NS,NT).NREC=NDATAPTS
            TSSED(NS,NT).VAL=0
            TSSED(NS,NT).TIM=0
          ENDDO
        ELSEIF( NN == 3 .AND. NSND > 0 .AND. NSNDSER > 0 )THEN
          DO NT=1,NSND
            ALLOCATE(TSSND(NS,NT).VAL(NDATAPTS,KCM),TSSND(NS,NT).TIM(NDATAPTS))    
            TSSND(NS,NT).NREC=NDATAPTS
            TSSND(NS,NT).VAL=0
            TSSND(NS,NT).TIM=0      
          ENDDO
        ENDIF
      
        ! *** SKIP THE CONVERSIONS
        IF( NN /= 1 )THEN
          DO NT=2,NLOOP
            READ(1,'(A)') SKIP
          ENDDO
        ENDIF

        NDCSER=MAX(NDCSER,NDATAPTS)
        IF( ISTYP == 1 )THEN
          ! *** SKIP THE SPLITS
          READ(1,'(A)') SKIP
        ENDIF
        ! *** SKIP TO THE NEXT SERIES
        DO M=1,NDATAPTS
          DO NT=1,NLOOP
            READ(1,'(A)') SKIP
          ENDDO
        ENDDO
      ENDDO
      CLOSE(1)
    ENDIF
  ENDDO
  RETURN

  20 WRITE(*,'(A)') '*** READ ERROR IN FILE: '//INFILE 
  WRITE(8,'(A)')    '*** READ ERROR IN FILE: '//INFILE
  STOP
  
  40 WRITE(*,'(A)') '*** UNEXPECTED END OF FILE: '//INFILE
  WRITE(8,'(A)')    '*** UNEXPECTED END OF FILE: '//INFILE
  STOP 

END SUBROUTINE
  
  
END MODULE
